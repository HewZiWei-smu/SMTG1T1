<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Methodology – G1T1: project_name</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-4968d28af72d4e5a34172c9bc5ef961b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">G1T1: project_name</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./overview.html"> 
<span class="menu-text">Overview</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./methodology.html" aria-current="page"> 
<span class="menu-text">Methodology</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./resultsdiscussion.html"> 
<span class="menu-text">Results &amp; Discussion</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./projectproposal.html"> 
<span class="menu-text">Project Proposal</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./lessonlearned.html"> 
<span class="menu-text">Lesson Learned</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./poster.html"> 
<span class="menu-text">Poster</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./webmap.html"> 
<span class="menu-text">WebMap</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preparation-procedures" id="toc-preparation-procedures" class="nav-link active" data-scroll-target="#preparation-procedures">PREPARATION PROCEDURES</a>
  <ul class="collapse">
  <li><a href="#data-preparation" id="toc-data-preparation" class="nav-link" data-scroll-target="#data-preparation">1.0.1 Data Preparation</a></li>
  <li><a href="#data-loading" id="toc-data-loading" class="nav-link" data-scroll-target="#data-loading">1.0.2 Data Loading</a></li>
  <li><a href="#data-exploration" id="toc-data-exploration" class="nav-link" data-scroll-target="#data-exploration">1.1.0 Data exploration</a></li>
  <li><a href="#areas-of-interest" id="toc-areas-of-interest" class="nav-link" data-scroll-target="#areas-of-interest">2.0.1 Areas of Interest</a></li>
  <li><a href="#increasing-ratio-of-green-spaces" id="toc-increasing-ratio-of-green-spaces" class="nav-link" data-scroll-target="#increasing-ratio-of-green-spaces">3.2.1 Increasing ratio of green spaces</a></li>
  <li><a href="#increasing-public-green-spaces" id="toc-increasing-public-green-spaces" class="nav-link" data-scroll-target="#increasing-public-green-spaces">3.2.2 Increasing public green spaces</a></li>
  <li><a href="#urban-tree-canopy" id="toc-urban-tree-canopy" class="nav-link" data-scroll-target="#urban-tree-canopy">3.2.3 Urban Tree Canopy</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Methodology</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="preparation-procedures" class="level2">
<h2 class="anchored" data-anchor-id="preparation-procedures">PREPARATION PROCEDURES</h2>
<section id="data-preparation" class="level3">
<h3 class="anchored" data-anchor-id="data-preparation">1.0.1 Data Preparation</h3>
<p>Goal: To download and prepare data 1. Download Copernicus data:</p>
<pre><code>On the Copernicus portal, select Copernicus L2A data for the Bangkok region. The filtering criteria would be &lt;5% cloud cover, and between January - March of 2020 and 2025. </code></pre>
<ol start="2" type="1">
<li><p>Download Bangkok GIS data:</p>
<p>Obtain the GeoJSON of the Bangkok Administrative Area</p></li>
</ol>
</section>
<section id="data-loading" class="level3">
<h3 class="anchored" data-anchor-id="data-loading">1.0.2 Data Loading</h3>
<ol type="1">
<li><p>Load the Copernicus datasets into QGIS.</p>
<p>Only load the B02, B03, B04, B08 layers for 2021 and 2025. Rename them according to the convention “B0[]_202[]“” and group them by year into groups.</p></li>
<li><p>Load the Bangkok GeoJSON into QGIS.</p>
<p>After loading, select attributes by Administrative Region = Bangkok. Save the selected attributes into a new layer, “Bangkok” and use it in place of the full layer.</p></li>
</ol>
</section>
<section id="data-exploration" class="level3">
<h3 class="anchored" data-anchor-id="data-exploration">1.1.0 Data exploration</h3>
<ol type="1">
<li><p>Band Set creation</p>
<p>For each year, create a new band set. Ensure the bands are in ascending order. After which, use the SCP plugin to use 4 - 3 - 2 False Color Composite and save the band set by year. This will help us easily identify vegeration from the raster data.</p></li>
<li><p>Normalized Difference Vegetation Index (NDVI) layers</p>
<p>Create NDVI layers for each year by using the raster calculator using the formula (B08 - B04) / (B08 + B04). Save the layer after checking. Once both years’ layers are created, created a difference layer using the formula (2025 NDVI - 2021 NDVI) to identify change in NDVI.</p></li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/overall_greenery_2021.jpg" class="img-fluid figure-img"></p>
<figcaption>Fig 1.1 Bangkok Greenery 2021</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/overall_greenery_2025.jpg" class="img-fluid figure-img"></p>
<figcaption>Fig 1.2 Bangkok Greenery 2025</figcaption>
</figure>
</div>
</section>
<section id="areas-of-interest" class="level3">
<h3 class="anchored" data-anchor-id="areas-of-interest">2.0.1 Areas of Interest</h3>
<ol type="1">
<li><p>Clip all raster layers to the Bangkok vector</p></li>
<li><p>Within the Bangkok region, bookmark the residential area of Lat Phrao and the CBD area of Chong Nonsi for further detailed analysis.</p></li>
</ol>
</section>
<section id="increasing-ratio-of-green-spaces" class="level3">
<h3 class="anchored" data-anchor-id="increasing-ratio-of-green-spaces">3.2.1 Increasing ratio of green spaces</h3>
<p>Goal: To determine whether Bangkok meets the target of 10 square meters of green space per person by comparing green space areas and population data between 2021 and 2025.</p>
<ol type="1">
<li><p>Prepare Data for Area Calculation:</p>
<p>The clipped green space layers for both 2021 and 2025 were projected to EPSG:32647 (UTM Zone 47N) to ensure accurate area calculations in square meters.</p></li>
<li><p>Calculate Green Space Area:</p>
<p>The Field Calculator was used to create a new field named area using the expression:</p>
<p>$area</p>
<p>This calculated the area of each polygon feature in square meters.</p></li>
<li><p>Select Public Green Spaces:</p>
<p>The Select Features by Expression tool was used to isolate only green space features classified as public.</p>
<p>The following expression was applied:</p>
<p>“2025_Vectored_Green” = 1</p></li>
<li><p>Compute Total Green Space Area:</p>
<p>The Statistics Panel was used to sum the values in the area field for the selected features.</p>
<p>The total green space areas were:</p>
<pre><code> 2025: 484,421,000 m² (484.421 km²)

 2021: 437,733,000 m² (437.733 km²)</code></pre></li>
<li><p>Calculate Net Change in Green Space:</p>
<p>The difference between the two years was calculated:</p>
<pre><code> Increase: 46.688 km² of green space from 2021 to 2025</code></pre></li>
<li><p>Obtain Population Data:</p>
<p>According to Macrotrends (n.d.), the population of Bangkok was:</p>
<pre><code> 2021: 10,723,000 people

 2025: 11,392,000 people</code></pre></li>
<li><p>Calculate Green Space Per Person (GSPP):</p>
<p>The formula used:</p>
<p>GSPP = Total&nbsp;Green&nbsp;Space&nbsp;Area&nbsp;(m²) / Population</p>
<p>Results:</p>
<pre><code> 2021 GSPP: 40.8&nbsp;sqm/person 
 ​
 2025 GSPP: 42.5&nbsp;sqm/person</code></pre></li>
<li><p>Conclusion:</p>
<p>Both years’ calculations exceed the minimum target of 10 sqm per person, with a modest increase of 1.7 sqm/person from 2021 to 2025.</p>
<p>This would indicates positive progress in enhancing urban green space access in Bangkok. However, this differs significantly from the publicly available data of 6sqm per person in 2021 and 7.3 sqm per person in 2025. We believe this to be differences in urban boundary establishment and / or differences in population statistics, to which we were unable to find official sources to determine the geographical boundary or population number to calculate from. Nevertheless, both the official and our calculated statistic reflects a growing urban greenery area in Bangkok.</p></li>
</ol>
</section>
<section id="increasing-public-green-spaces" class="level3">
<h3 class="anchored" data-anchor-id="increasing-public-green-spaces">3.2.2 Increasing public green spaces</h3>
<p>Applying an Area Threshold</p>
<p>To ensure meaningful analysis of publicly accessible green spaces, an area threshold of 10,000 m² (1 hectare) was applied. This step filters out minor vegetation features such as street medians, roadside trees, and small decorative patches, which are unlikely to serve as formal public parks or recreational areas.</p>
<p>Expression used in QGIS:</p>
<p>“2021_Vectored_Gr” = 1 AND “area” &gt; 10000</p>
<p>This refinement:</p>
<p>Retains only green features larger than 10,000 m²</p>
<p>Likely captures significant green zones such as public parks and urban forests</p>
<p>Eliminates smaller, non-functional or inaccessible green patches</p>
<p>The resulting dataset allows for a more realistic assessment of green space accessibility.</p>
<p>2021 Analysis: In 2021, filtered features from the “Clipped Natural Greenery 2021” layer were buffered using a 400-meter radius to represent walkable access to green areas. The output was dissolved to prevent overlap inflation and clipped to Bangkok’s administrative boundary.</p>
<p>Buffered Area: 346,418,000 m²</p>
<p>Total Bangkok Area: ~1,570,000,000 m²</p>
<p>Accessibility Coverage: 22.06%</p>
<p>This indicates that just over one-fifth of the city was within 400 meters of a significant public green space in 2021.</p>
<p>2025 Analysis: Using the same methodology, the 2025 dataset was filtered and processed. The buffer zone was again limited to 400 meters, dissolved, and clipped to Bangkok’s boundary.</p>
<p>Buffered Area: 394,777,000 m²</p>
<p>Accessibility Coverage: 25.14%</p>
<p>This shows a modest increase in access, reflecting some progress toward Bangkok’s green space targets.</p>
<p>Conclusion: From 2021 to 2025, the proportion of Bangkok’s land area within 400 meters of large public green spaces increased from 22.06% to 25.14%, reflecting a 3.08 percentage point improvement.</p>
<p>While this growth is positive, it still falls short of the 50% target for universal walkable access to green spaces. This highlights the need for continued investment in park development, better spatial planning, and potentially more equitable green space distribution across the city.</p>
</section>
<section id="urban-tree-canopy" class="level3">
<h3 class="anchored" data-anchor-id="urban-tree-canopy">3.2.3 Urban Tree Canopy</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/access_greenery_2021_lp.jpg" class="img-fluid figure-img"></p>
<figcaption>Fig 1.3 Lat Phrao Access to Greenery 2021</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/access_greenery_2025_lp.jpg" class="img-fluid figure-img"></p>
<figcaption>Fig 1.4 Lat Phrao Access to Greenery 2025</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/chong_nonsi_access_to_greenery_2021.jpg" class="img-fluid figure-img"></p>
<figcaption>Fig 1.5 Chong Nonsi Access to Greenery 2021</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/chong_nonsi_access_to_greenery_2025.jpg" class="img-fluid figure-img"></p>
<figcaption>Fig 1.6 Chong Nonsi Access to Greenery 2025</figcaption>
</figure>
</div>
<p>To evaluate changes in visible tree cover across Bangkok from 2021 to 2025, a multi-step remote sensing approach was used:</p>
<p>Satellite Imagery Selection Copernicus Sentinel-2 Level 2A data was sourced for January–March 2021 and 2025, with cloud cover below 5%.</p>
<p>NDVI &amp; Band Selection A vegetation density index was created using bands B02, B03, B04, and B08 at 10-meter resolution.</p>
<p>Tree Detection via Classification A Random Forest classification model was trained to detect tree cover specifically, improving differentiation between grass, shrubs, and trees.</p>
<p>Vectorization &amp; Area Calculation The classified raster was vectorized to allow for area-based analysis of greenery.</p>
<p>Urban Tree Canopy Ratio Tree canopy ratio was calculated using:</p>
<p>Tree Canopy Ratio = Greenery Area / Total Area of Sample Location</p>
<p>This was applied to two contrasting urban zones — Chong Nonsi (CBD) and Lat Phrao (Residential) — to compare greenery in dense vs.&nbsp;suburban context</p>
<p>Results: 2021: 16.6% 2025: 19%</p>
<p>Conclusion: Between 2021 and 2025, Bangkok’s urban tree canopy ratio increased from 16.6% to 19%, indicating a positive trend in visible tree coverage. This growth suggests that efforts to expand urban greenery—whether through tree planting or preserving existing canopy—are beginning to take effect.</p>
<p>However, the relatively small increase (+2.4 percentage points) highlights that progress is gradual and may be uneven across different urban zones. The comparison between Chong Nonsi (CBD) and Lat Phrao (Residential) also reflects the challenge of expanding greenery in high-density areas, where space constraints limit planting opportunities.</p>
<p>This suggests that while the city is moving in the right direction, accelerated and location-sensitive greening strategies are still needed to meet long-term urban sustainability goals.</p>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">References</h3>
<ol type="1">
<li>Macrotrends. (n.d.). Bangkok, Thailand Metro Area Population 1950-2024. Retrieved March 30, 2025, from ‘https://www.macrotrends.net/cities/22617/bangkok/population’</li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>